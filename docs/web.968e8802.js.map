{"version":3,"sources":["src/underdash/index.ts","src/dependencyContainer/index.ts","src/gamePiece/enums.ts","src/config/index.ts","src/game/enums.ts","src/eventDispatcher/enums.ts","src/scenes/menuTemplate.ts","src/scenes/menu/index.ts","src/scenes/sceneController.ts","src/options/index.ts","src/gamePiece/utils.ts","src/gamePiece/index.ts","src/scenes/gameState/levelController.ts","src/scenes/gameState/index.ts","src/scenes/options/index.ts","src/scenes/highScore/index.ts","src/eventDispatcher/index.ts","src/game/index.ts","src/render/color.ts","src/render/terminal.ts","src/render/web.ts","src/input/web.ts","src/highScore/web.ts","node_modules/process/browser.js","src/input/terminal.ts","src/highScore/terminal.ts","src/index.ts","src/web.ts"],"names":["cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","call","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","Item","array","noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"web.968e8802.js","sourceRoot":"..","sourcesContent":["// some util functions\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const isEmptyObject = (obj: Object): boolean =>\n  Object.entries(obj).length === 0 && obj.constructor === Object;\n\nexport const wrapModulo = (x: number, n: number): number => ((x % n) + n) % n;\n\n// TODO refactor (has unit tests)\nexport const lineWrap = (str: string, maxLength: number): string => {\n  const words = str.match(/\\S+/g) || [];\n\n  if (words.length === 0) {\n    return '';\n  }\n\n  let lines: string[] = [];\n  let nextLine = '';\n  words.forEach((word, index) => {\n    if (nextLine === '' && word.length <= maxLength) {\n      nextLine = word;\n    } else if (`${nextLine} ${word}`.length <= maxLength) {\n      nextLine = `${nextLine} ${word}`;\n    } else if (word.length > maxLength) {\n      if (nextLine.length >= maxLength - 1) {\n        lines.push(nextLine);\n        nextLine = '';\n      } else {\n        nextLine += ' ';\n      }\n      word.split('').forEach(char => {\n        if (`${nextLine}${char}`.length < maxLength) {\n          nextLine += char;\n        } else {\n          lines.push(`${nextLine}-`);\n          nextLine = char;\n        }\n      });\n    } else {\n      lines.push(nextLine);\n      nextLine = word;\n    }\n\n    if (index === words.length - 1) {\n      lines.push(nextLine);\n    }\n  });\n\n  // TODO optimize this\n  lines = lines.map(line => {\n    if (line.length === maxLength) {\n      return line;\n    }\n\n    let rightPad = '';\n    for (let i = 0; i < maxLength - line.length; i++) {\n      rightPad += ' ';\n    }\n    return line + rightPad;\n  });\n\n  return lines.join('\\n');\n};\n\nexport const expandString = (\n  input: string,\n  widthFactor: number,\n  heightFactor: number\n): string => {\n  const lines = input.split('\\n');\n  let result = '';\n  lines.forEach(line => {\n    let expandedLine = '';\n    line.split('').forEach(char => {\n      for (let i = 0; i < widthFactor; i++) {\n        expandedLine += char;\n      }\n    });\n    expandedLine += '\\n';\n    for (let i = 0; i < heightFactor; i++) {\n      result += expandedLine;\n    }\n  });\n  return result.replace(/\\n$/, '');\n};\n","import { Dependencies } from './types';\nimport { isEmptyObject } from '../underdash';\nimport { GameCharSelector } from '../config/types';\nimport { SetupInputListeners } from '../input/types';\nimport { Render } from '../render/types';\n\nclass DependencyContainer {\n  private constructor() {}\n\n  private static dependencies: Dependencies;\n\n  public static initialize(dependencies: Dependencies): void {\n    if (!dependencies || isEmptyObject(dependencies)) {\n      throw new Error('No dependencies supplied');\n    }\n\n    DependencyContainer.dependencies = dependencies;\n  }\n\n  public static resolve(\n    dependencyName: keyof Dependencies\n  ): Render | SetupInputListeners | GameCharSelector | HighScore | undefined {\n    // TODO could be cleaner\n    if (!DependencyContainer.dependencies) {\n      throw new Error('Dependency container is not initialized');\n    }\n    const dependency = DependencyContainer.dependencies[dependencyName];\n    return dependency;\n  }\n}\n\nexport default DependencyContainer;\n","export enum GAME_PIECE_TYPE {\n  T = 1,\n  L,\n  L_INVERTED,\n  S,\n  S_INVERTED,\n  I,\n  BLOCK,\n  EMPTY_SPACE\n}\n","import { GAME_PIECE_TYPE } from '../gamePiece/enums';\nimport { GameCharSelector } from './types';\n\nexport const WEB_ENV = 'WEB_ENV';\nexport const TERMINAL_ENV = 'TERMINAL_ENV';\nexport const TEST_ENV = 'TEST_ENV';\n\nexport const COLUMNS = 10;\nexport const ROWS = 16;\n\nconst GAME_CHARS: Record<string, Record<string, string>> = {\n  [WEB_ENV]: {\n    [GAME_PIECE_TYPE.L]: 'l',\n    [GAME_PIECE_TYPE.L_INVERTED]: 'j',\n    [GAME_PIECE_TYPE.S]: 's',\n    [GAME_PIECE_TYPE.S_INVERTED]: 'z',\n    [GAME_PIECE_TYPE.T]: 't',\n    [GAME_PIECE_TYPE.I]: 'i',\n    [GAME_PIECE_TYPE.BLOCK]: 'o',\n    [GAME_PIECE_TYPE.EMPTY_SPACE]: ' '\n  },\n  [TERMINAL_ENV]: {\n    [GAME_PIECE_TYPE.L]: 'l',\n    [GAME_PIECE_TYPE.L_INVERTED]: 'l',\n    [GAME_PIECE_TYPE.S]: 's',\n    [GAME_PIECE_TYPE.S_INVERTED]: 's',\n    [GAME_PIECE_TYPE.T]: 't',\n    [GAME_PIECE_TYPE.I]: 'i',\n    [GAME_PIECE_TYPE.BLOCK]: 'o',\n    [GAME_PIECE_TYPE.EMPTY_SPACE]: ' '\n  },\n  [TEST_ENV]: {\n    [GAME_PIECE_TYPE.L]: 'l',\n    [GAME_PIECE_TYPE.L_INVERTED]: 'l',\n    [GAME_PIECE_TYPE.S]: 's',\n    [GAME_PIECE_TYPE.S_INVERTED]: 's',\n    [GAME_PIECE_TYPE.T]: 't',\n    [GAME_PIECE_TYPE.I]: 'i',\n    [GAME_PIECE_TYPE.BLOCK]: 'o',\n    [GAME_PIECE_TYPE.EMPTY_SPACE]: ' '\n  }\n};\n\nexport const createGameCharSelector = (env: string): GameCharSelector => {\n  const chars = GAME_CHARS[env];\n  return (char: GAME_PIECE_TYPE): string => chars[char];\n};\n","/*\n\nPossible scene transitions\n\n+--------------+         +-------------+\n|              |-------->|             |\n| Start screen |         | Active game |\n|              |<--------|             |\n+--------------+         +-------------+\n  ^ |      ^ | \n  | |      | |   +------------+\n  | |      | +-->|            |\n  | |      |     | High score |\n  | |      +-----|            |\n  | v            +------------+\n+---------+              \n|         |\n| Options |\n|         |\n+---------+\n\n*/\n\nexport enum SceneTransition {\n  StartToGame,\n  GameToStart,\n  StartToOptions,\n  OptionsToStart,\n  StartToHighScore,\n  HighScoreToStart\n}\n","// TODO think about other solution to this\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport enum EventType {\n  InputUp = 'InputUp',\n  InputDown = 'InputDown',\n  InputLeft = 'InputLeft',\n  InputRight = 'InputRight',\n  Confirmation = 'Confirmation',\n  Pause = 'Pause',\n  Rotate = 'Rotate',\n  RotateReverse = 'RotateReverse',\n  GravityDrop = 'GravityDrop',\n  QuickDrop = 'QuickDrop',\n  StartGravityInterval = 'StartGravityInterval',\n  IncreaseGravityInterval = 'IncreaseGravityInterval',\n  ClearGravityInterval = 'ClearGravityInterval',\n  Restart = 'Restart',\n  ToggleGhostPieceOption = 'ToggleGhostPieceOption',\n  ToggleConsoleRenderingOption = 'ToggleConsoleRenderingOption',\n  Render = 'Render'\n}\n","import { wrapModulo } from '../underdash';\nimport { MenuItem } from './types';\nimport { Scene } from '../game/types';\nimport { EventType } from '../eventDispatcher/enums';\nimport { HandleEvent } from '../eventDispatcher/types';\nimport { Render } from '../render/types';\nimport { GameStateRepresentation } from './gameState/types';\nimport { Options } from '../options/types';\n\nconst createMenu = (\n  render: Render,\n  menuItems: MenuItem[],\n  options: Options,\n  text?: string\n): Scene => {\n  let activeMenuIndex = 0;\n\n  const getRepresentation = (): GameStateRepresentation => {\n    let representation = '';\n\n    if (text) {\n      representation += `${text.trim()}\\n\\n`;\n    }\n\n    menuItems.forEach((item, index): void => {\n      if (index === activeMenuIndex) {\n        representation += `-> ${item.text()}\\n`;\n      } else {\n        representation += `   ${item.text()}\\n`;\n      }\n    });\n\n    return {\n      renderString: representation,\n      nextPieceString: '',\n      score: 0,\n      level: 1,\n      clearedLines: 0,\n      options\n    };\n  };\n\n  const handleEvent: HandleEvent = event => {\n    switch (event.type) {\n      case EventType.InputDown:\n        activeMenuIndex = wrapModulo(activeMenuIndex + 1, menuItems.length);\n        render(getRepresentation());\n        break;\n      case EventType.InputUp:\n        activeMenuIndex = wrapModulo(activeMenuIndex - 1, menuItems.length);\n        render(getRepresentation());\n        break;\n      case EventType.Render:\n        render(getRepresentation());\n        break;\n      case EventType.Confirmation:\n      case EventType.Rotate:\n      case EventType.RotateReverse:\n        menuItems[activeMenuIndex].action();\n        break;\n      default:\n        break;\n    }\n  };\n\n  // initial render\n  render(getRepresentation());\n\n  return {\n    handleEvent\n  };\n};\n\nexport default createMenu;\n","import { SceneTransition } from '../../game/enums';\nimport { SceneInitializer, MenuItem } from '../types';\nimport createMenu from '../menuTemplate';\nimport DependencyContainer from '../../dependencyContainer';\nimport { Render } from '../../render/types';\n\nconst initializeMenu: SceneInitializer = ({ changeScene, options }) => {\n  const render: Render = DependencyContainer.resolve('render') as Render;\n\n  const menuItems: MenuItem[] = [\n    {\n      text: (): string => 'Start game',\n      action: (): void => changeScene(SceneTransition.StartToGame)\n    },\n    {\n      text: (): string => 'Options',\n      action: (): void => changeScene(SceneTransition.StartToOptions)\n    },\n    {\n      text: (): string => 'High score',\n      action: (): void => changeScene(SceneTransition.StartToHighScore)\n    }\n  ];\n\n  const menu = createMenu(render, menuItems, options);\n\n  return menu;\n};\n\nexport default initializeMenu;\n","import { Scene, ChangeScene } from '../game/types';\nimport {\n  SceneInitializer,\n  SceneTransitionMapping,\n  SceneController\n} from './types';\nimport { EventDispatcher, UnregisterCallback } from '../eventDispatcher/types';\nimport { EventType } from '../eventDispatcher/enums';\nimport { Options } from '../options/types';\n\nconst initializeSceneController = (\n  startingSceneInitializer: SceneInitializer,\n  sceneTransitions: SceneTransitionMapping[],\n  eventDispatcher: EventDispatcher,\n  options: Options\n): SceneController => {\n  let activeScene: Scene;\n  let unregisterCallback: UnregisterCallback;\n\n  const changeScene: ChangeScene = sceneTransition => {\n    const sceneTransitionMapping:\n      | SceneTransitionMapping\n      | undefined = sceneTransitions.find(\n      (e): boolean => e.transition === sceneTransition\n    );\n\n    if (!sceneTransitionMapping) {\n      throw new Error('No scene initializer found');\n    }\n\n    activeScene = sceneTransitionMapping.initializer({\n      changeScene,\n      dispatch: eventDispatcher.dispatch,\n      options\n    });\n    if (unregisterCallback) {\n      unregisterCallback();\n    }\n    unregisterCallback = eventDispatcher.register(activeScene);\n\n    // TODO FIX THIS. We don't want to start gravity on every scene.\n    // initial gravity\n    eventDispatcher.dispatch({ type: EventType.StartGravityInterval });\n  };\n\n  // create first scene\n  activeScene = startingSceneInitializer({\n    changeScene,\n    dispatch: eventDispatcher.dispatch,\n    options\n  });\n  unregisterCallback = eventDispatcher.register(activeScene);\n\n  return {\n    changeScene\n  };\n};\n\nexport default initializeSceneController;\n","import { DispatchEvent } from '../eventDispatcher/types';\nimport { EventType } from '../eventDispatcher/enums';\nimport { GameOptions } from './types';\n\nconst initializeGameOptions = (): GameOptions => {\n  const options = {\n    ghostPieceActive: true,\n    consoleRenderingActive: false\n  };\n\n  const eventClient = {\n    handleEvent: (event: DispatchEvent): void => {\n      if (event.type === EventType.ToggleGhostPieceOption) {\n        options.ghostPieceActive = !options.ghostPieceActive;\n      }\n      if (event.type === EventType.ToggleConsoleRenderingOption) {\n        options.consoleRenderingActive = !options.consoleRenderingActive;\n      }\n    }\n  };\n\n  return {\n    options,\n    eventClient\n  };\n};\n\nexport default initializeGameOptions;\n","import { GAME_PIECE_TYPE } from './enums';\nimport DependencyContainer from '../dependencyContainer';\nimport { GameCharSelector } from '../config/types';\nimport { Coordinate, CoordinateData, RotationOptions } from './types';\n\nexport const getMinMaxCoordinates = (\n  coordinates: Coordinate[]\n): [Coordinate, Coordinate] => {\n  let minX = Number.MAX_SAFE_INTEGER;\n  let minY = Number.MAX_SAFE_INTEGER;\n  let maxX = Number.MIN_SAFE_INTEGER;\n  let maxY = Number.MIN_SAFE_INTEGER;\n  coordinates.forEach((coordinate): void => {\n    const { x, y } = coordinate;\n    if (x > maxX) {\n      maxX = x;\n    }\n    if (x < minX) {\n      minX = x;\n    }\n    if (y > maxY) {\n      maxY = y;\n    }\n    if (y < minY) {\n      minY = y;\n    }\n  });\n\n  return [\n    {\n      x: minX,\n      y: minY\n    },\n    {\n      x: maxX,\n      y: maxY\n    }\n  ];\n};\n\n// determines if longest side in piece has an odd (like a \"T\"-piece)\n// or even (like a \"I\"-piece) amount of blocks\nexport const isLongestSideEven = (coordinates: Coordinate[]): boolean => {\n  const [min, max] = getMinMaxCoordinates(coordinates);\n  const xDistance = max.x - min.x + 1;\n  const yDistance = max.y - min.y + 1;\n  const longestDistance = xDistance > yDistance ? xDistance : yDistance;\n  const isLongestDistanceEven = longestDistance % 2 === 0;\n\n  return isLongestDistanceEven;\n};\n\nconst pieceBag: GAME_PIECE_TYPE[] = [];\nexport const getNextPieceType = (): GAME_PIECE_TYPE => {\n  const pieceTypes = [\n    GAME_PIECE_TYPE.T,\n    GAME_PIECE_TYPE.L,\n    GAME_PIECE_TYPE.L_INVERTED,\n    GAME_PIECE_TYPE.S,\n    GAME_PIECE_TYPE.S_INVERTED,\n    GAME_PIECE_TYPE.I,\n    GAME_PIECE_TYPE.BLOCK\n  ];\n\n  if (pieceBag.length === 0) {\n    pieceTypes.forEach(pieceType => {\n      pieceBag.push(pieceType);\n    });\n  }\n\n  const nextTypeIndex = Math.floor(Math.random() * pieceBag.length);\n\n  const nextType = pieceBag.splice(nextTypeIndex, 1)[0];\n\n  return nextType;\n};\n\nexport const getPieceChar = (pieceType: GAME_PIECE_TYPE): string => {\n  // TODO maybe inject these?\n  const gameCharSelector = DependencyContainer.resolve(\n    'gameCharSelector'\n  ) as GameCharSelector; // TODO should be automatic\n\n  switch (pieceType) {\n    case GAME_PIECE_TYPE.L:\n    case GAME_PIECE_TYPE.L_INVERTED:\n    case GAME_PIECE_TYPE.S:\n    case GAME_PIECE_TYPE.S_INVERTED:\n    case GAME_PIECE_TYPE.T:\n    case GAME_PIECE_TYPE.I:\n    case GAME_PIECE_TYPE.BLOCK:\n      return gameCharSelector(pieceType);\n    default:\n      throw new Error(`Unknown piece type - ${pieceType}`);\n  }\n};\n\nexport const getInitialCoordinates = (\n  pieceType: GAME_PIECE_TYPE,\n  center: Coordinate\n): Coordinate[] => {\n  switch (pieceType) {\n    case GAME_PIECE_TYPE.T:\n      //  x\n      // xxx\n      return [\n        {\n          x: center.x,\n          y: center.y - 1\n        },\n        {\n          x: center.x - 1,\n          y: center.y\n        },\n        {\n          x: center.x,\n          y: center.y\n        },\n        {\n          x: center.x + 1,\n          y: center.y\n        }\n      ];\n    case GAME_PIECE_TYPE.L:\n      //   x\n      // xxx\n      return [\n        {\n          x: center.x + 1,\n          y: center.y - 1\n        },\n        {\n          x: center.x - 1,\n          y: center.y\n        },\n        {\n          x: center.x,\n          y: center.y\n        },\n        {\n          x: center.x + 1,\n          y: center.y\n        }\n      ];\n    case GAME_PIECE_TYPE.L_INVERTED:\n      // x\n      // xxx\n      return [\n        {\n          x: center.x - 1,\n          y: center.y - 1\n        },\n        {\n          x: center.x - 1,\n          y: center.y\n        },\n        {\n          x: center.x,\n          y: center.y\n        },\n        {\n          x: center.x + 1,\n          y: center.y\n        }\n      ];\n    case GAME_PIECE_TYPE.S:\n      //  xx\n      // xx\n      return [\n        {\n          x: center.x,\n          y: center.y - 1\n        },\n        {\n          x: center.x + 1,\n          y: center.y - 1\n        },\n        {\n          x: center.x - 1,\n          y: center.y\n        },\n        {\n          x: center.x,\n          y: center.y\n        }\n      ];\n    case GAME_PIECE_TYPE.S_INVERTED:\n      // xx\n      //  xx\n      return [\n        {\n          x: center.x - 1,\n          y: center.y - 1\n        },\n        {\n          x: center.x,\n          y: center.y - 1\n        },\n        {\n          x: center.x,\n          y: center.y\n        },\n        {\n          x: center.x + 1,\n          y: center.y\n        }\n      ];\n    case GAME_PIECE_TYPE.I:\n      return [\n        {\n          x: center.x - 1,\n          y: center.y\n        },\n        {\n          x: center.x,\n          y: center.y\n        },\n        {\n          x: center.x + 1,\n          y: center.y\n        },\n        {\n          x: center.x + 2,\n          y: center.y\n        }\n      ];\n    case GAME_PIECE_TYPE.BLOCK:\n      return [\n        {\n          x: center.x,\n          y: center.y\n        },\n        {\n          x: center.x + 1,\n          y: center.y\n        },\n        {\n          x: center.x,\n          y: center.y + 1\n        },\n        {\n          x: center.x + 1,\n          y: center.y + 1\n        }\n      ];\n    default:\n      throw new Error(`Unknown piece type - ${pieceType}`);\n  }\n};\n\nexport const transpose = (\n  coordinates: Coordinate[],\n  origo: Coordinate,\n  dx: number,\n  dy: number\n): CoordinateData => {\n  return {\n    coordinates: coordinates.map(\n      (coordinate): Coordinate => ({\n        x: coordinate.x + dx,\n        y: coordinate.y + dy\n      })\n    ),\n    origo: {\n      x: origo.x + dx,\n      y: origo.y + dy\n    }\n  };\n};\n\n// TODO refactor\nexport const getNextRotation = (\n  args: CoordinateData & RotationOptions\n): CoordinateData => {\n  const { coordinates, origo, reverse } = args;\n  // General rotation algorithm:\n  // Keep track of origo and use relative positioning of all the pieces.\n  // For each rotation: x2 = y1 * -1, y2 = x1\n\n  let nextOrigo: Coordinate = {\n    x: origo.x,\n    y: origo.y\n  };\n\n  const needsTemporaryOrigoCross = isLongestSideEven(coordinates);\n\n  let nextCoordinates: Coordinate[] = coordinates.map(\n    (coordinate): Coordinate => {\n      const inTopLeftQuadrant =\n        coordinate.x <= nextOrigo.x && coordinate.y <= nextOrigo.y;\n      if (!needsTemporaryOrigoCross || inTopLeftQuadrant) {\n        return {\n          x: coordinate.x,\n          y: coordinate.y\n        };\n      }\n\n      return {\n        x: coordinate.x > nextOrigo.x ? coordinate.x + 1 : coordinate.x,\n        y: coordinate.y > nextOrigo.y ? coordinate.y + 1 : coordinate.y\n      };\n    }\n  );\n\n  if (needsTemporaryOrigoCross) {\n    nextOrigo = {\n      x: nextOrigo.x + 1,\n      y: nextOrigo.y + 1\n    };\n  }\n\n  nextCoordinates = nextCoordinates.map(\n    (coordinate): Coordinate => {\n      const dx1 = coordinate.x - nextOrigo.x;\n      const dy1 = coordinate.y - nextOrigo.y;\n\n      let dx2: number;\n      let dy2: number;\n\n      if (!reverse) {\n        dx2 = dy1 * -1;\n        dy2 = dx1;\n      } else {\n        dx2 = dy1;\n        dy2 = dx1 * -1;\n      }\n\n      const x2 = nextOrigo.x + dx2;\n      const y2 = nextOrigo.y + dy2;\n\n      return {\n        x: x2,\n        y: y2\n      };\n    }\n  );\n\n  // delete origo cross\n  if (needsTemporaryOrigoCross) {\n    nextOrigo = {\n      x: nextOrigo.x - 1,\n      y: nextOrigo.y - 1\n    };\n\n    nextCoordinates = nextCoordinates.map(\n      (coordinate): Coordinate => {\n        if (coordinate.x <= nextOrigo.x && coordinate.y <= nextOrigo.y) {\n          return coordinate;\n        }\n        return {\n          x: coordinate.x > nextOrigo.x ? coordinate.x - 1 : coordinate.x,\n          y: coordinate.y > nextOrigo.y ? coordinate.y - 1 : coordinate.y\n        };\n      }\n    );\n  }\n\n  return { coordinates: nextCoordinates, origo: nextOrigo };\n};\n","import {\n  getMinMaxCoordinates,\n  transpose,\n  getNextRotation,\n  getInitialCoordinates,\n  getPieceChar\n} from './utils';\nimport { GAME_PIECE_TYPE } from './enums';\nimport {\n  Coordinate,\n  GamePiece,\n  CoordinateData,\n  SetState,\n  GetPreview,\n  GetChar,\n  GetNextState,\n  GetState\n} from './types';\nimport { EventType } from '../eventDispatcher/enums';\nimport { COLUMNS } from '../config';\n\n// Borrowing some React wording here.\n//\n// I'm thinking that a given game piece\n// should return it's next state on\n// any given input, and let external\n// logic decide if it's a valid move.\n//\n// So state updates will happen separately\n// from input handling.\nexport const createGamePiece = (pieceType: GAME_PIECE_TYPE): GamePiece => {\n  const center: Coordinate = {\n    x: 2,\n    y: 2\n  };\n  let coordinates = getInitialCoordinates(pieceType, center);\n\n  let origo = {\n    x: center.x,\n    y: center.y\n  };\n\n  // make sure piece starts from the top\n  const [min] = getMinMaxCoordinates(coordinates);\n\n  const transposition = transpose(\n    coordinates,\n    origo,\n    COLUMNS / 2 - origo.x - 1,\n    0 - min.y\n  );\n  coordinates = transposition.coordinates;\n  origo = transposition.origo;\n\n  // initial values\n  let char = getPieceChar(pieceType);\n  let moves = 0;\n\n  const getState: GetState = () => {\n    const state = {\n      coordinates,\n      origo,\n      moves\n    };\n    return state;\n  };\n\n  const getNextTransposition = (eventType: EventType): CoordinateData => {\n    switch (eventType) {\n      case EventType.InputLeft:\n        return transpose(coordinates, origo, -1, 0);\n      case EventType.InputRight:\n        return transpose(coordinates, origo, 1, 0);\n      case EventType.InputUp:\n        return transpose(coordinates, origo, 0, -1);\n      case EventType.InputDown:\n        return transpose(coordinates, origo, 0, 1);\n      case EventType.Rotate: {\n        const nextRotation = getNextRotation({\n          coordinates,\n          origo,\n          reverse: false\n        });\n        return {\n          coordinates: nextRotation.coordinates,\n          origo: nextRotation.origo\n        };\n      }\n      case EventType.RotateReverse: {\n        const nextRotation = getNextRotation({\n          coordinates,\n          origo,\n          reverse: true\n        });\n        return {\n          coordinates: nextRotation.coordinates,\n          origo: nextRotation.origo\n        };\n      }\n      case EventType.GravityDrop:\n        // same as input down, but I think we're gonna rebuild this\n        return transpose(coordinates, origo, 0, 1);\n      default:\n        // don't alter anything\n        return {\n          coordinates,\n          origo\n        };\n    }\n  };\n\n  const getNextState: GetNextState = eventType => {\n    const transposition = getNextTransposition(eventType);\n    return { ...transposition, moves };\n  };\n\n  const getChar: GetChar = () => char;\n\n  const setState: SetState = nextState => {\n    // TODO generalize and clean up this..\n    if (nextState.coordinates !== null && nextState.coordinates !== undefined) {\n      coordinates = nextState.coordinates;\n    }\n    if (nextState.origo !== null && nextState.origo !== undefined) {\n      origo = nextState.origo;\n    }\n    if (nextState.moves !== null && nextState.moves !== undefined) {\n      moves = nextState.moves;\n    }\n  };\n\n  const getPreview: GetPreview = () =>\n    getInitialCoordinates(pieceType, { x: 0, y: 0 });\n\n  const getType = () => pieceType;\n\n  // public API\n  return {\n    getNextState,\n    setState,\n    getState,\n    getChar,\n    getPreview,\n    getType\n  };\n};\n","const getGravityDelay = (level: number): number =>\n  Math.pow(0.8 - (level - 1) * 0.007, level - 1) * 1000;\n\nclass LevelController {\n  private _gravityInterval: number;\n  private _level: number;\n\n  public constructor() {\n    this._level = 1;\n    this._gravityInterval = getGravityDelay(this._level);\n  }\n\n  // TODO re-think public api (we should think in levels)\n  public increaseLevel(): void {\n    if (this._level < 15) {\n      this._level += 1;\n      this._gravityInterval = getGravityDelay(this._level);\n    }\n  }\n\n  public setLevel(level: number): void {\n    if (level >= 1 && level <= 15) {\n      this._level = level;\n      this._gravityInterval = getGravityDelay(this._level);\n    }\n  }\n\n  public getLevel(): number {\n    return this._level;\n  }\n\n  public getGravityInterval(): number {\n    return this._gravityInterval;\n  }\n}\n\nexport default LevelController;\n","import { createGamePiece } from '../../gamePiece/index';\nimport { GAME_PIECE_TYPE } from '../../gamePiece/enums';\nimport {\n  getMinMaxCoordinates,\n  transpose,\n  getNextPieceType\n} from '../../gamePiece/utils';\nimport { COLUMNS, ROWS } from '../../config';\nimport { GameCharSelector } from '../../config/types';\nimport DependencyContainer from '../../dependencyContainer';\nimport { SceneInitializer } from '../types';\nimport { Coordinate, GamePiece, GamePieceState } from '../../gamePiece/types';\nimport { HandleEvent } from '../../eventDispatcher/types';\nimport { EventType } from '../../eventDispatcher/enums';\nimport { Render } from '../../render/types';\nimport LevelController from './levelController';\nimport { GameStateRepresentation } from './types';\nimport { SceneTransition } from '../../game/enums';\n\n// TODO give this whole file some love\nexport enum GameState {\n  Active = 'Active',\n  GameOver = 'GameOver',\n  Paused = 'Paused'\n}\n\nexport const initializeGameState: SceneInitializer = ({\n  changeScene,\n  dispatch,\n  options\n}) => {\n  // inject dependencies\n  const gameCharSelector: GameCharSelector = DependencyContainer.resolve(\n    'gameCharSelector'\n  ) as GameCharSelector; // TODO should be automatic\n  const render: Render = DependencyContainer.resolve('render') as Render;\n  const highScore: HighScore = DependencyContainer.resolve(\n    'highScore'\n  ) as HighScore;\n  const EMPTY_SPACE_CHAR = gameCharSelector(GAME_PIECE_TYPE.EMPTY_SPACE);\n\n  // state\n  let activePiece: GamePiece;\n  let ghostPiece: GamePiece;\n  let nextPiece: GamePiece;\n  let gameState: GameState;\n  let clearedLines: number;\n  let score: number;\n  let gameBoard: string[][];\n  let levelController: LevelController;\n\n  function isValidMove(coordinates: Coordinate[]): boolean {\n    let validMove = true;\n\n    for (let i = 0; i < coordinates.length; i++) {\n      const coordinate = coordinates[i];\n      // check for out of bounds\n      if (\n        coordinate.x < 0 ||\n        coordinate.x >= COLUMNS ||\n        coordinate.y < 0 ||\n        coordinate.y >= ROWS\n      ) {\n        validMove = false;\n        break;\n      }\n\n      // check for collision with rest of board\n      if (gameBoard[coordinate.y][coordinate.x] !== EMPTY_SPACE_CHAR) {\n        validMove = false;\n      }\n    }\n\n    return validMove;\n  }\n\n  function pushToBottom(gamePiece: GamePiece): void {\n    let validMove = true;\n\n    do {\n      let nextState = gamePiece.getNextState(EventType.GravityDrop);\n      if (nextState.moves === undefined) {\n        throw new Error(\"Expected to find property 'moves' on nextState\");\n      }\n      validMove = isValidMove(nextState.coordinates);\n      if (validMove) {\n        // we're manipulating our arguments here..\n        gamePiece.setState({ ...nextState, moves: nextState.moves + 1 });\n      }\n    } while (validMove);\n  }\n\n  const initialize = (): void => {\n    levelController = new LevelController();\n\n    const initialPieceType = getNextPieceType();\n    const initialPiece = createGamePiece(initialPieceType);\n    const next = createGamePiece(getNextPieceType());\n\n    // setup state\n    activePiece = initialPiece;\n    ghostPiece = createGamePiece(initialPieceType);\n\n    nextPiece = next;\n    gameState = GameState.Active;\n    clearedLines = 0;\n    score = 0;\n    gameBoard = [];\n    for (let y = 0; y < ROWS; y++) {\n      gameBoard[y] = [];\n      for (let x = 0; x < COLUMNS; x++) {\n        gameBoard[y][x] = EMPTY_SPACE_CHAR;\n      }\n    }\n\n    pushToBottom(ghostPiece);\n  };\n\n  const getRepresentation = (): GameStateRepresentation => {\n    // this might be a weird way to do it, but it's a start!\n\n    // create buffer of game state board\n    const gameBoardBuffer: string[][] = [];\n    for (let y = 0; y < ROWS; y++) {\n      gameBoardBuffer[y] = [];\n      for (let x = 0; x < COLUMNS; x++) {\n        gameBoardBuffer[y][x] = gameBoard[y][x];\n      }\n    }\n\n    // place active piece\n    const state = activePiece.getState();\n    state.coordinates.forEach((coordinate): void => {\n      gameBoardBuffer[coordinate.y][coordinate.x] = activePiece.getChar();\n    });\n\n    // generate string representation\n    let renderString = '';\n    for (let y = 0; y < ROWS; y++) {\n      for (let x = 0; x < COLUMNS; x++) {\n        renderString += gameBoardBuffer[y][x];\n      }\n      if (y < ROWS - 1) {\n        renderString += '\\n';\n      }\n    }\n\n    // not sure if we should just use a big string, or split the \"UI\" up\n\n    const nextPiecePreview = nextPiece.getPreview();\n    let pieceCoordinates: string[][] = [];\n    nextPiecePreview.forEach((coordinate): void => {\n      if (!pieceCoordinates[coordinate.y]) {\n        pieceCoordinates[coordinate.y] = [];\n      }\n      pieceCoordinates[coordinate.y][coordinate.x] = nextPiece.getChar();\n    });\n\n    let previewString = '';\n    const [min, max] = getMinMaxCoordinates(nextPiecePreview);\n    for (let y = min.y; y <= max.y; y++) {\n      for (let x = min.x; x <= max.x; x++) {\n        previewString += pieceCoordinates[y][x] || EMPTY_SPACE_CHAR;\n      }\n      if (y < max.y) {\n        previewString += '\\n';\n      }\n    }\n\n    return {\n      renderString,\n      nextPieceString: previewString,\n      score,\n      level: levelController.getLevel(),\n      clearedLines,\n      gameBoard: gameBoardBuffer,\n      nextPiece,\n      ghostPiece: options.ghostPieceActive ? ghostPiece : undefined,\n      options\n    };\n  };\n\n  const renderGameState = (): void => {\n    render(getRepresentation(), gameState);\n  };\n\n  // TODO move gravity handling to separate module\n  let gravityInterval: NodeJS.Timeout;\n  const setGravityInterval = (interval: number): void => {\n    if (gravityInterval) {\n      clearInterval(gravityInterval);\n    }\n\n    const triggerGravityDrop = (): void => {\n      dispatch({ type: EventType.GravityDrop });\n      renderGameState();\n    };\n\n    gravityInterval = setInterval(triggerGravityDrop, interval);\n  };\n\n  const clearGravityInterval = (): void => {\n    if (gravityInterval !== null) {\n      clearInterval(gravityInterval);\n    }\n  };\n\n  const startNewGame = (): void => {\n    initialize();\n    renderGameState();\n    dispatch({\n      type: EventType.StartGravityInterval\n    });\n  };\n\n  const handleEvent: HandleEvent = event => {\n    switch (event.type) {\n      case EventType.Pause:\n        if (gameState === GameState.Active) {\n          gameState = GameState.Paused;\n          dispatch({\n            type: EventType.ClearGravityInterval\n          });\n        } else if (gameState === GameState.Paused) {\n          gameState = GameState.Active;\n          dispatch({\n            type: EventType.StartGravityInterval\n          });\n        }\n        break;\n      case EventType.Restart:\n        if (gameState !== GameState.GameOver) {\n          break;\n        }\n\n        startNewGame();\n\n        break;\n      case EventType.StartGravityInterval:\n        setGravityInterval(levelController.getGravityInterval());\n        break;\n      case EventType.ClearGravityInterval:\n        clearGravityInterval();\n        break;\n      case EventType.InputUp:\n        break;\n      case EventType.InputLeft:\n      case EventType.InputRight:\n      case EventType.Rotate:\n      case EventType.RotateReverse: {\n        if (\n          event.type === EventType.RotateReverse &&\n          (gameState === GameState.Paused || gameState === GameState.GameOver)\n        ) {\n          changeScene(SceneTransition.OptionsToStart);\n          return;\n        }\n\n        if (gameState !== GameState.Active) {\n          break;\n        }\n\n        let nextState = activePiece.getNextState(event.type);\n        const validMove = isValidMove(nextState.coordinates);\n\n        if (validMove) {\n          activePiece.setState(nextState);\n          ghostPiece.setState(nextState);\n\n          pushToBottom(ghostPiece);\n\n          break;\n        }\n\n        // try to wall kick if possible\n        if (\n          event.type === EventType.Rotate ||\n          event.type === EventType.RotateReverse\n        ) {\n          // try x and y axis offsets separately\n          const wallKickOffsetsX = [1, 2, -1, -2];\n          for (const wallKickOffset of wallKickOffsetsX) {\n            const transposition = transpose(\n              nextState.coordinates,\n              nextState.origo,\n              wallKickOffset,\n              0\n            );\n            if (isValidMove(transposition.coordinates)) {\n              activePiece.setState(transposition);\n              ghostPiece.setState(transposition);\n              pushToBottom(ghostPiece);\n              break;\n            }\n          }\n\n          const wallKickOffsetsY = [1];\n          for (const wallKickOffset of wallKickOffsetsY) {\n            const transposition = transpose(\n              nextState.coordinates,\n              nextState.origo,\n              0,\n              wallKickOffset\n            );\n            if (isValidMove(transposition.coordinates)) {\n              activePiece.setState(transposition);\n              ghostPiece.setState(transposition);\n              pushToBottom(ghostPiece);\n              break;\n            }\n          }\n        }\n\n        break;\n      }\n      case EventType.QuickDrop:\n        if (gameState !== GameState.Active) {\n          break;\n        }\n\n        // TODO possible performance thief\n        dispatch({ type: EventType.StartGravityInterval });\n        let nextState: GamePieceState;\n        let validMove = true;\n        let droppedLines = 0;\n        do {\n          nextState = activePiece.getNextState(EventType.GravityDrop);\n          if (nextState.moves === undefined) {\n            throw new Error(\"Expected to find property 'moves' on nextState\");\n          }\n          validMove = isValidMove(nextState.coordinates);\n          if (validMove) {\n            activePiece.setState({ ...nextState, moves: nextState.moves + 1 });\n            droppedLines += 1;\n          }\n        } while (validMove);\n\n        // hard drop scoring\n        score += 2 * droppedLines;\n\n        dispatch({ type: EventType.GravityDrop });\n        break;\n      case EventType.InputDown:\n      case EventType.GravityDrop: {\n        if (gameState !== GameState.Active) {\n          break;\n        }\n        // TODO possible performance thief\n        dispatch({ type: EventType.StartGravityInterval });\n\n        const nextState = activePiece.getNextState(event.type);\n\n        if (nextState.moves === undefined) {\n          throw new Error(\"Expected to find property 'moves' on nextState\");\n        }\n\n        const validMove = isValidMove(nextState.coordinates);\n        if (validMove) {\n          activePiece.setState({ ...nextState, moves: nextState.moves + 1 });\n        } else {\n          if (nextState.moves === 0) {\n            dispatch({\n              type: EventType.ClearGravityInterval\n            });\n            gameState = GameState.GameOver;\n            highScore.save(score);\n            break;\n          }\n          // this is where a piece lands\n          // lots of stuff happening. maybe break it out to separate functions for clarity.\n\n          // transfer active piece to game board\n          const activePieceCoordinates = activePiece.getState().coordinates;\n          activePieceCoordinates.forEach((coordinate): void => {\n            gameBoard[coordinate.y][coordinate.x] = activePiece.getChar();\n          });\n\n          // check for solid lines\n          const solidRows: number[] = [];\n          for (let y = ROWS - 1; y >= 0; y--) {\n            let solid = true;\n            for (let x = 0; x < COLUMNS; x++) {\n              if (gameBoard[y][x] === EMPTY_SPACE_CHAR) {\n                solid = false;\n                break;\n              }\n            }\n            if (solid) {\n              solidRows.push(y);\n            }\n          }\n\n          // clear solid lines\n          solidRows.forEach((y): void => {\n            for (let x = 0; x < COLUMNS; x++) {\n              gameBoard[y][x] = EMPTY_SPACE_CHAR;\n            }\n          });\n\n          // move everything down after clearace\n          if (solidRows.length > 0) {\n            // start at first solid line row minus one\n            for (let y = solidRows[0] - 1; y >= 0; y--) {\n              for (let x = 0; x < COLUMNS; x++) {\n                if (gameBoard[y][x] !== EMPTY_SPACE_CHAR) {\n                  const pieceChar = gameBoard[y][x];\n\n                  // only move max the number of lines cleared\n                  const CLEARED_LINES = solidRows.filter((e): boolean => e > y)\n                    .length;\n\n                  let nextY = y;\n                  let freeSpaceDownwards = true;\n                  while (freeSpaceDownwards && nextY < y + CLEARED_LINES) {\n                    if (gameBoard[nextY + 1][x] === EMPTY_SPACE_CHAR) {\n                      nextY++;\n                    } else {\n                      freeSpaceDownwards = false;\n                    }\n                  }\n\n                  // only swap if piece was moved\n                  if (y !== nextY) {\n                    gameBoard[y][x] = EMPTY_SPACE_CHAR;\n                    gameBoard[nextY][x] = pieceChar;\n                  }\n                }\n              }\n            }\n          }\n\n          // calculate score\n          let nextScore = 0;\n          const level = levelController.getLevel();\n          switch (solidRows.length) {\n            case 0:\n              break;\n            case 1:\n              nextScore += 100 * level;\n              break;\n            case 2:\n              nextScore += 300 * level;\n              break;\n            case 3:\n              nextScore += 500 * level;\n              break;\n            case 4:\n              nextScore += 800 * level;\n              break;\n            default:\n              throw new Error(\n                \"We shouldn't be able to clear more than 4 lines in one play..\"\n              );\n          }\n\n          score += nextScore;\n\n          // crude level increaser\n          solidRows.forEach(() => {\n            clearedLines += 1;\n          });\n          levelController.setLevel(Math.floor(clearedLines / 15) + 1);\n          dispatch({\n            type: EventType.StartGravityInterval\n          });\n\n          // add new active piece\n          const newPiece = createGamePiece(getNextPieceType());\n          ghostPiece = createGamePiece(nextPiece.getType());\n\n          pushToBottom(ghostPiece);\n\n          activePiece = nextPiece;\n          nextPiece = newPiece;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n\n    renderGameState();\n  };\n\n  // kick off everything\n  startNewGame();\n\n  return {\n    handleEvent\n  };\n};\n","import { SceneInitializer, MenuItem } from '../types';\nimport { SceneTransition } from '../../game/enums';\nimport createMenu from '../menuTemplate';\nimport DependencyContainer from '../../dependencyContainer';\nimport { Render } from '../../render/types';\nimport { EventType } from '../../eventDispatcher/enums';\n\nconst initializeOptions: SceneInitializer = params => {\n  const { changeScene, dispatch, options } = params;\n\n  const render: Render = DependencyContainer.resolve('render') as Render;\n\n  const menuItems: MenuItem[] = [\n    {\n      text: (): string =>\n        `Ghost pieces - ${options.ghostPieceActive ? 'on' : 'off'}`,\n      action: (): void => {\n        dispatch({ type: EventType.ToggleGhostPieceOption });\n        dispatch({ type: EventType.Render });\n      }\n    },\n    {\n      // TODO only in web environment\n      text: (): string =>\n        `Console rendering - ${options.consoleRenderingActive ? 'on' : 'off'}`,\n      action: (): void => {\n        dispatch({ type: EventType.ToggleConsoleRenderingOption });\n        dispatch({ type: EventType.Render });\n      }\n    },\n    {\n      text: (): string => 'Back to start screen',\n      action: (): void => changeScene(SceneTransition.OptionsToStart)\n    }\n  ];\n\n  const menu = createMenu(render, menuItems, options);\n\n  return menu;\n};\n\nexport default initializeOptions;\n","import { SceneInitializer, MenuItem } from '../types';\nimport { SceneTransition } from '../../game/enums';\nimport createMenu from '../menuTemplate';\nimport { Render } from '../../render/types';\nimport DependencyContainer from '../../dependencyContainer';\n\nconst initializeHighScore: SceneInitializer = params => {\n  const { changeScene, dispatch, options } = params;\n\n  const highScore = DependencyContainer.resolve('highScore') as HighScore;\n  const highScores = highScore.load();\n\n  const render: Render = DependencyContainer.resolve('render') as Render;\n\n  const menuItems: MenuItem[] = [\n    {\n      text: (): string => 'Back',\n      action: (): void => changeScene(SceneTransition.HighScoreToStart)\n    }\n  ];\n\n  const text = highScores.map((score, i) => `${i + 1} - ${score}`).join('\\n');\n\n  const menu = createMenu(render, menuItems, options, text);\n\n  return menu;\n};\n\nexport default initializeHighScore;\n","import {\n  DispatchEvent,\n  UnregisterCallback,\n  EventDispatcher,\n  IdentityClient,\n  Client\n} from './types';\n\nconst createEventDispatcher = (): EventDispatcher => {\n  let _clients: IdentityClient[] = [];\n  let _id = 0;\n\n  const _unregister = (id: number): void => {\n    _clients = _clients.filter((client): boolean => client.id !== id);\n  };\n\n  const register = (client: Client): UnregisterCallback => {\n    const nextId = _id;\n    _id += 1;\n\n    _clients.push({\n      ...client,\n      id: nextId\n    });\n\n    return (): void => _unregister(nextId);\n  };\n\n  const dispatch = (event: DispatchEvent): void => {\n    _clients.forEach((client): void => {\n      client.handleEvent(event);\n    });\n  };\n\n  return {\n    register,\n    dispatch\n  };\n};\n\nexport default createEventDispatcher;\n","import DependencyContainer from '../dependencyContainer';\nimport initializeMenu from '../scenes/menu';\nimport initializeSceneController from '../scenes/sceneController';\nimport initializeGameOptions from '../options';\nimport { SceneTransitionMapping } from '../scenes/types';\nimport { SceneTransition } from './enums';\nimport { initializeGameState } from '../scenes/gameState';\nimport initializeOptions from '../scenes/options';\nimport initializeHighScore from '../scenes/highScore';\nimport createEventDispatcher from '../eventDispatcher';\nimport { EventType } from '../eventDispatcher/enums';\nimport { SetupInputListeners } from '../input/types';\n\nconst initializeGame = (): void => {\n  // resolve dependencies\n  const setupInputListeners = DependencyContainer.resolve(\n    'setupInputListeners'\n  ) as SetupInputListeners; // TODO should be automatic\n\n  const sceneTransitions: SceneTransitionMapping[] = [\n    {\n      transition: SceneTransition.StartToGame,\n      initializer: initializeGameState\n    },\n    {\n      transition: SceneTransition.StartToOptions,\n      initializer: initializeOptions\n    },\n    {\n      transition: SceneTransition.OptionsToStart,\n      initializer: initializeMenu\n    },\n    {\n      transition: SceneTransition.GameToStart,\n      initializer: initializeMenu\n    },\n    {\n      transition: SceneTransition.StartToHighScore,\n      initializer: initializeHighScore\n    },\n    {\n      transition: SceneTransition.HighScoreToStart,\n      initializer: initializeMenu\n    }\n  ];\n\n  // create event dispatcher\n  const eventDispatcher = createEventDispatcher();\n\n  const options = initializeGameOptions();\n  eventDispatcher.register(options.eventClient);\n\n  initializeSceneController(\n    initializeMenu,\n    sceneTransitions,\n    eventDispatcher,\n    options.options\n  );\n\n  // map inputs to dispatch events\n  const dispatchInputEvent = (eventType: EventType): void => {\n    eventDispatcher.dispatch({\n      type: eventType\n    });\n  };\n\n  setupInputListeners({ handleInput: dispatchInputEvent });\n};\n\nexport default initializeGame;\n","// TODO cache previously created colors(?)\nclass Color {\n  private red: number;\n  private green: number;\n  private blue: number;\n  private alpha?: number;\n\n  // validators\n  private withinColorRange = (colors: number[]): boolean => {\n    colors.forEach(color => {\n      if (color < 0 || color > 255) {\n        return false;\n      }\n    });\n    return true;\n  };\n\n  private withinAlphaRange = (alpha: number): boolean => {\n    return alpha >= 0 && alpha <= 1;\n  };\n\n  public constructor(r: number, g: number, b: number, a: number = 1) {\n    if (!this.withinColorRange([r, g, b]) || !this.withinAlphaRange(a)) {\n      throw new Error('Invalid values supplied to Color constructor');\n    }\n\n    this.red = r;\n    this.green = g;\n    this.blue = b;\n    this.alpha = a;\n  }\n\n  public toString(): string {\n    return `rgb(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;\n  }\n\n  public setAlpha(alpha: number): Color {\n    if (!this.withinAlphaRange(alpha)) {\n      throw new Error('Invalid alpha value supplied to setAlpha method');\n    }\n    return new Color(this.red, this.green, this.blue, alpha);\n  }\n}\n\nexport default Color;\n","import { lineWrap, expandString } from '../underdash';\nimport { Render } from './types';\nimport { GameState } from '../scenes/gameState';\nimport { Coordinate } from '../gamePiece/types';\nimport { createGameCharSelector, TERMINAL_ENV } from '../config';\nimport { GAME_PIECE_TYPE } from '../gamePiece/enums';\n\nconst EXPAND_WIDTH = 4;\nconst EXPAND_HEIGHT = 2;\n\nconst gameCharSelector = createGameCharSelector(TERMINAL_ENV);\nconst EMPTY_SPACE = gameCharSelector(GAME_PIECE_TYPE.EMPTY_SPACE);\n\nconst render: Render = (param, gameState): void => {\n  const {\n    renderString,\n    nextPieceString: nextPiece,\n    score,\n    level,\n    gameBoard,\n    ghostPiece\n  } = param;\n\n  if (!renderString) {\n    throw new Error('No render string supplied');\n  }\n\n  let stringToRender = renderString;\n\n  if (gameBoard) {\n    let ghostPieceCoordinates: Coordinate[] = [];\n    if (ghostPiece) {\n      ghostPieceCoordinates = ghostPiece.getState().coordinates;\n    }\n    stringToRender = '';\n    for (let y = 0; y < gameBoard.length; y++) {\n      for (let x = 0; x < gameBoard[0].length; x++) {\n        let nextCell = gameBoard[y][x];\n        for (const ghostCoordinate of ghostPieceCoordinates) {\n          if (\n            ghostCoordinate.x === x &&\n            ghostCoordinate.y === y &&\n            nextCell === EMPTY_SPACE\n          ) {\n            nextCell = '.';\n          }\n        }\n        stringToRender += nextCell;\n      }\n      if (y < gameBoard.length - 1) {\n        stringToRender += '\\n';\n      }\n    }\n\n    // only expand game board\n    stringToRender = expandString(stringToRender, EXPAND_WIDTH, EXPAND_HEIGHT);\n  }\n\n  const addInfoWindow = (renderString: string, infoText: string): string => {\n    const lines = renderString.split('\\n');\n    let longestLineLength = 0;\n    lines.forEach(line => {\n      if (line.length > longestLineLength) {\n        longestLineLength = line.length;\n      }\n    });\n\n    const MODAL_WIDTH = 20;\n    const MODAL_X_OFFSET = longestLineLength / 2 - MODAL_WIDTH / 2;\n    const MODAL_Y_OFFSET = 10;\n    const VERTICAL_PADDING = 1;\n    const HORIZONTAL_PADDING = 1;\n\n    let wrappedText = lineWrap(\n      infoText,\n      MODAL_WIDTH - 2 - 2 * VERTICAL_PADDING\n    );\n\n    const lineCount = wrappedText.split('\\n').length;\n\n    wrappedText = wrappedText.split('\\n').join('');\n\n    const MODAL_HEIGHT = lineCount + 2 * HORIZONTAL_PADDING + 2;\n\n    const result = lines.map((line, index) => {\n      const isFirstOrLastLine =\n        index === MODAL_Y_OFFSET || index === MODAL_Y_OFFSET + MODAL_HEIGHT - 1;\n      if (isFirstOrLastLine) {\n        return line\n          .split('')\n          .map((c, i) => {\n            if (\n              i === MODAL_X_OFFSET ||\n              i === MODAL_X_OFFSET + MODAL_WIDTH - 1\n            ) {\n              return '+';\n            } else if (\n              i >= MODAL_X_OFFSET &&\n              i < MODAL_X_OFFSET + MODAL_WIDTH\n            ) {\n              return '-';\n            }\n            return c;\n          })\n          .join('');\n      }\n\n      const isInBetweenLine =\n        index > MODAL_Y_OFFSET && index < MODAL_Y_OFFSET + MODAL_HEIGHT - 1;\n      const isInVerticalPadding =\n        index < MODAL_Y_OFFSET + VERTICAL_PADDING + 1 ||\n        index >= MODAL_Y_OFFSET + MODAL_HEIGHT - 1 - VERTICAL_PADDING;\n      if (isInBetweenLine) {\n        return line\n          .split('')\n          .map((c, i) => {\n            if (\n              i === MODAL_X_OFFSET ||\n              i === MODAL_X_OFFSET + MODAL_WIDTH - 1\n            ) {\n              return '|';\n            } else if (\n              i >= MODAL_X_OFFSET &&\n              i < MODAL_X_OFFSET + MODAL_WIDTH\n            ) {\n              const isInHorizontalPadding =\n                i < MODAL_X_OFFSET + HORIZONTAL_PADDING + 1 ||\n                i >= MODAL_X_OFFSET + MODAL_WIDTH - 1 - HORIZONTAL_PADDING;\n              if (\n                isInVerticalPadding ||\n                isInHorizontalPadding ||\n                wrappedText.length === 0\n              ) {\n                return ' ';\n              }\n              // TODO could optimize this by keeping an index counter\n              // instead of creating n new strings\n              const nextChar = wrappedText[0];\n              wrappedText = wrappedText.substring(1);\n\n              return nextChar;\n            }\n            return c;\n          })\n          .join('');\n      }\n\n      return line;\n    });\n\n    return result.join('\\n');\n  };\n\n  let renderStringWithInfo = stringToRender;\n\n  if (gameState && gameState === GameState.GameOver) {\n    renderStringWithInfo = addInfoWindow(\n      renderStringWithInfo,\n      \"Game over! Press 'r' to play again.\"\n    );\n  }\n\n  if (gameState && gameState === GameState.Paused) {\n    renderStringWithInfo = addInfoWindow(renderStringWithInfo, 'Game paused');\n  }\n\n  const minHeight = (string: string, height: number): string => {\n    const lines = string.split('\\n').length;\n    if (lines >= height) {\n      return string;\n    }\n\n    const newlines = expandString('\\n', height - lines, 1);\n    return `${string}${newlines}`;\n  };\n\n  let output = '';\n  output += `level: ${level}\\n`;\n  output += `score: ${score}\\n`;\n  output += 'next:\\n';\n  output += expandString(\n    minHeight(`${nextPiece}\\n`, 3),\n    EXPAND_WIDTH,\n    EXPAND_HEIGHT\n  );\n  output += '{{replace-me}}\\n';\n  output += renderStringWithInfo;\n  const lines = output.split('\\n');\n  let longestLine = 0;\n  lines.forEach(line => {\n    if (line.length > longestLine) {\n      longestLine = line.length;\n    }\n  });\n  let display = '';\n  display += '+';\n  display += expandString('-', longestLine, 1);\n  display += '+\\n';\n  lines.forEach(line => {\n    const lineLength = line.length;\n    let padding = '';\n    if (lineLength < longestLine) {\n      padding = expandString(' ', longestLine - lineLength, 1);\n    }\n    if (line.includes('{{replace-me}}')) {\n      display += `+${expandString('-', longestLine, 1)}+\\n`;\n    } else {\n      display += `|${line}${padding}|\\n`;\n    }\n  });\n  display += '+';\n  display += expandString('-', longestLine, 1);\n  display += '+\\n';\n  if (console.clear) {\n    console.clear();\n  } else {\n    console.log('\\x1b[2J');\n  }\n  console.log(display);\n};\n\nexport default render;\n","import { Render } from './types';\nimport { GAME_PIECE_TYPE } from '../gamePiece/enums';\nimport { getMinMaxCoordinates, transpose } from '../gamePiece/utils';\nimport { WEB_ENV, COLUMNS, ROWS, createGameCharSelector } from '../config';\nimport { GameState } from '../scenes/gameState';\nimport Color from './color';\nimport { lineWrap } from '../underdash';\n\nimport terminalRender from './terminal';\n\nconst T_COLOR = new Color(171, 0, 235);\nconst L_COLOR = new Color(252, 158, 0);\nconst L_INVERTED_COLOR = new Color(45, 0, 248);\nconst S_COLOR = new Color(0, 254, 0);\nconst S_INVERTED_COLOR = new Color(255, 0, 0);\nconst I_COLOR = new Color(0, 185, 224);\nconst BLOCK_COLOR = new Color(237, 247, 0);\n\nconst createRender = (): Render => {\n  const gameCharSelector = createGameCharSelector(WEB_ENV);\n\n  // could be cleaner\n  const EMPTY_SPACE_CHAR = gameCharSelector(GAME_PIECE_TYPE.EMPTY_SPACE);\n\n  const T = gameCharSelector(GAME_PIECE_TYPE.T);\n  const L = gameCharSelector(GAME_PIECE_TYPE.L);\n  const L_INVERTED = gameCharSelector(GAME_PIECE_TYPE.L_INVERTED);\n  const S = gameCharSelector(GAME_PIECE_TYPE.S);\n  const S_INVERTED = gameCharSelector(GAME_PIECE_TYPE.S_INVERTED);\n  const I = gameCharSelector(GAME_PIECE_TYPE.I);\n  const BLOCK = gameCharSelector(GAME_PIECE_TYPE.BLOCK);\n\n  const getPieceColor = (piece: string): Color => {\n    switch (piece) {\n      case T:\n        return T_COLOR;\n      case L:\n        return L_COLOR;\n      case L_INVERTED:\n        return L_INVERTED_COLOR;\n      case S:\n        return S_COLOR;\n      case S_INVERTED:\n        return S_INVERTED_COLOR;\n      case I:\n        return I_COLOR;\n      case BLOCK:\n        return BLOCK_COLOR;\n      default:\n        return new Color(255, 255, 255);\n    }\n  };\n\n  const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n\n  if (!canvas) {\n    throw new Error('Could not find canvas element');\n  }\n\n  const ctx = canvas.getContext('2d');\n\n  if (!ctx) {\n    throw new Error('Could not find context element');\n  }\n\n  const CANVAS_HEIGHT_PADDING = 50;\n  const CANVAS_HEIGHT = window.innerHeight - CANVAS_HEIGHT_PADDING;\n  const CANVAS_WIDTH = CANVAS_HEIGHT / 2;\n\n  ctx.canvas.height = CANVAS_HEIGHT;\n  ctx.canvas.width = CANVAS_WIDTH;\n\n  const CELL_WIDTH = CANVAS_WIDTH / COLUMNS;\n  const CELL_HEIGHT = CELL_WIDTH;\n  const INITIAL_Y = CANVAS_HEIGHT - ROWS * CELL_HEIGHT;\n  const INITIAL_X = 0;\n\n  const render: Render = (param, gameState) => {\n    const {\n      renderString,\n      gameBoard,\n      nextPiece,\n      score,\n      level,\n      ghostPiece,\n      clearedLines,\n      options\n    } = param;\n\n    if (options && options.consoleRenderingActive) {\n      terminalRender(param, gameState);\n    } else {\n      console.clear();\n    }\n\n    // TODO pass which screen we are rendering, instead of checking gameState\n\n    if (!renderString) {\n      throw new Error('Render string was not supplied to render function');\n    }\n\n    // (comment for trailing effect)\n    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n    // draw game board background\n    ctx.fillStyle = new Color(255, 255, 255, 0.25).toString();\n    ctx.fillRect(INITIAL_X, INITIAL_Y, CANVAS_WIDTH, CANVAS_HEIGHT - INITIAL_Y);\n\n    // render functions for different parts of UI\n    const renderNextPiece = (): void => {\n      if (nextPiece) {\n        const PREVIEW_WIDTH = CELL_WIDTH / 2;\n        const PREVIEW_HEIGHT = CELL_HEIGHT / 2;\n\n        const INITIAL_X = CANVAS_WIDTH - 5 * PREVIEW_WIDTH;\n        const INITIAL_Y = 0;\n\n        ctx.fillStyle = new Color(0, 0, 0).toString();\n        ctx.font = '18px monospace';\n        ctx.fillText('Next:', INITIAL_X - 60, INITIAL_Y + 20);\n\n        const color = getPieceColor(nextPiece.getChar());\n        ctx.fillStyle = color.toString();\n\n        const { coordinates, origo } = nextPiece.getState();\n        const [min] = getMinMaxCoordinates(coordinates);\n        transpose(coordinates, origo, min.x * -1, 0).coordinates.forEach(\n          coordinate => {\n            const { x, y } = coordinate;\n\n            ctx.fillRect(\n              INITIAL_X + PREVIEW_WIDTH * x,\n              INITIAL_Y + PREVIEW_HEIGHT * y,\n              PREVIEW_WIDTH,\n              PREVIEW_HEIGHT\n            );\n          }\n        );\n      }\n    };\n\n    const renderGameBoard = (): void => {\n      if (gameBoard) {\n        for (let y = 0; y < gameBoard.length; y++) {\n          for (let x = 0; x < gameBoard[0].length; x++) {\n            const cell = gameBoard[y][x];\n            if (cell !== EMPTY_SPACE_CHAR) {\n              const color = getPieceColor(cell);\n              ctx.fillStyle = color.toString();\n              ctx.fillRect(\n                INITIAL_X + x * CELL_WIDTH,\n                INITIAL_Y + y * CELL_HEIGHT,\n                CELL_WIDTH,\n                CELL_HEIGHT\n              );\n\n              ctx.strokeStyle = new Color(0, 0, 0).toString();\n              ctx.lineWidth = 1;\n              ctx.strokeRect(\n                INITIAL_X + x * CELL_WIDTH,\n                INITIAL_Y + y * CELL_HEIGHT,\n                CELL_WIDTH,\n                CELL_HEIGHT\n              );\n            }\n          }\n        }\n      }\n    };\n\n    const renderGhostPiece = (): void => {\n      if (ghostPiece) {\n        const color = getPieceColor(ghostPiece.getChar()).setAlpha(0.15);\n        ctx.fillStyle = color.toString();\n        ghostPiece.getState().coordinates.forEach(({ x, y }) => {\n          ctx.fillRect(\n            INITIAL_X + x * CELL_WIDTH,\n            INITIAL_Y + y * CELL_HEIGHT,\n            CELL_WIDTH,\n            CELL_HEIGHT\n          );\n        });\n      }\n    };\n\n    const renderMenuChoice = (): void => {\n      const TEXT_COLOR = new Color(0, 0, 0).toString();\n      const TEXT_FONT = '18px monospace';\n      ctx.fillStyle = TEXT_COLOR;\n      ctx.font = TEXT_FONT;\n\n      const lines = renderString.split('\\n');\n\n      const FONT_SIZE = 16;\n      ctx.font = `${FONT_SIZE}px monospace`;\n      const LINE_HEIGHT = CELL_HEIGHT;\n      for (let i = 0; i < lines.length; i++) {\n        ctx.fillText(\n          lines[i],\n          CELL_WIDTH,\n          INITIAL_Y + 2 * CELL_HEIGHT + i * LINE_HEIGHT\n        );\n      }\n    };\n\n    const renderHUD = (): void => {\n      const START_Y = 20;\n      const LINE_HEIGHT = 25;\n      const TEXT_COLOR = new Color(0, 0, 0).toString();\n      const TEXT_FONT = '18px monospace';\n      ctx.fillStyle = TEXT_COLOR;\n      ctx.font = TEXT_FONT;\n      ctx.fillText(`Level: ${level}`, 0, START_Y);\n      ctx.fillText(`Score: ${score}`, 0, START_Y + LINE_HEIGHT);\n      ctx.fillText(\n        `Cleared lines: ${clearedLines}`,\n        0,\n        START_Y + 2 * LINE_HEIGHT\n      );\n    };\n\n    const renderModal = (text: string): void => {\n      const MODAL_HORIZONTAL_PADDING = CELL_WIDTH;\n      const MODAL_MARGIN_TOP = CELL_HEIGHT * 2;\n      const MODAL_INNER_PADDING = CELL_WIDTH;\n\n      const charactersPerLine =\n        (CANVAS_WIDTH -\n          2 * MODAL_HORIZONTAL_PADDING -\n          2 * MODAL_INNER_PADDING) /\n        (CELL_WIDTH / 2);\n      const lines = lineWrap(text, charactersPerLine).split('\\n');\n\n      const MODAL_HEIGHT = CELL_HEIGHT * 2 + CELL_HEIGHT * lines.length;\n\n      ctx.fillStyle = new Color(0, 0, 0, 0.5).toString();\n      ctx.fillRect(\n        MODAL_HORIZONTAL_PADDING,\n        INITIAL_Y + MODAL_MARGIN_TOP,\n        CANVAS_WIDTH - MODAL_HORIZONTAL_PADDING * 2,\n        MODAL_HEIGHT\n      );\n\n      ctx.fillStyle = new Color(255, 255, 255).toString();\n      const FONT_SIZE = CELL_WIDTH / 2;\n      ctx.font = `${FONT_SIZE}px monospace`;\n      const LINE_HEIGHT = CELL_HEIGHT;\n      for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n        const line = lines[lineIndex];\n        for (let charIndex = 0; charIndex < line.length; charIndex++) {\n          ctx.fillText(\n            line.charAt(charIndex),\n            MODAL_HORIZONTAL_PADDING +\n              MODAL_INNER_PADDING +\n              charIndex * (CELL_WIDTH / 3),\n            INITIAL_Y +\n              MODAL_MARGIN_TOP +\n              FONT_SIZE +\n              MODAL_INNER_PADDING +\n              lineIndex * LINE_HEIGHT\n          );\n        }\n      }\n    };\n\n    // trigger render functions\n    renderNextPiece();\n    renderGhostPiece();\n    renderGameBoard();\n    if (gameState) {\n      renderHUD();\n    }\n    if (!gameState) {\n      renderMenuChoice();\n    }\n    if (gameState && gameState === GameState.GameOver) {\n      renderModal('Game over!\\n(r) restart\\n(q) quit');\n    }\n    if (gameState && gameState === GameState.Paused) {\n      renderModal('Game paused. Press \"q\" to exit to menu.');\n    }\n  };\n\n  return render;\n};\n\nexport default createRender;\n","import { EventType } from '../eventDispatcher/enums';\nimport { SetupInputListenersParam } from './types';\n\nconst setupInputListeners = (param: SetupInputListenersParam): void => {\n  const { handleInput } = param;\n\n  // will probably break with multi touch.\n  let touches: Touch[] = [];\n\n  function getEventType(dx: number, dy: number, clientX: number): EventType {\n    if (dx === 0 && dy === 0) {\n      // tap\n      // determine position on screen\n      if (clientX > window.innerWidth / 2) {\n        return EventType.Rotate;\n      } else {\n        return EventType.RotateReverse;\n      }\n    }\n\n    const horizontalSwipe = Math.abs(dx) > Math.abs(dy);\n    if (horizontalSwipe) {\n      if (dx > 0) {\n        return EventType.InputRight;\n      } else {\n        return EventType.InputLeft;\n      }\n    } else {\n      // TODO test on different devices..\n      if (dy > 200) {\n        console.log(dy);\n        return EventType.QuickDrop;\n      } else if (dy > 0) {\n        return EventType.InputDown;\n      } else {\n        return EventType.InputUp;\n      }\n    }\n  }\n\n  function handleKeyDown(event: KeyboardEvent): void {\n    // event key codes\n    const LEFT = 37;\n    const RIGHT = 39;\n    const UP = 38;\n    const DOWN = 40;\n    const Q = 81;\n    const E = 69;\n    const R = 82;\n    const W = 87;\n    const SPACE = 32;\n    const ENTER = 13;\n    const ESCAPE = 27;\n\n    const inputMapping: {\n      [index: number]: EventType;\n    } = {\n      [LEFT]: EventType.InputLeft,\n      [RIGHT]: EventType.InputRight,\n      [UP]: EventType.InputUp,\n      [DOWN]: EventType.InputDown,\n      [E]: EventType.Rotate,\n      [Q]: EventType.RotateReverse,\n      [W]: EventType.QuickDrop,\n      [SPACE]: EventType.GravityDrop,\n      [ENTER]: EventType.Confirmation,\n      [R]: EventType.Restart,\n      [ESCAPE]: EventType.Pause\n    };\n\n    const inputType = inputMapping[event.keyCode];\n    if (inputType !== undefined) {\n      handleInput(inputMapping[event.keyCode]);\n    }\n  }\n\n  function handleTouchStart(event: TouchEvent): void {\n    touches.push(event.touches[0]);\n  }\n\n  function handleTouchMove(event: TouchEvent): void {\n    touches.push(event.touches[0]);\n  }\n\n  function handleTouchEnd(): void {\n    const initialTouch = touches[0];\n    const lastTouch = touches[touches.length - 1];\n\n    const dx = lastTouch.pageX - initialTouch.pageX;\n    const dy = lastTouch.pageY - initialTouch.pageY;\n\n    const inputType = getEventType(dx, dy, lastTouch.clientX);\n    handleInput(inputType);\n\n    touches = [];\n  }\n\n  function handleTouchCancel(): void {\n    // not really sure when this is triggered. delegate it to touch end handler for now.\n    handleTouchEnd();\n  }\n\n  const element = document.getElementById('wrapper');\n\n  if (!element) {\n    throw new Error('Element did not exist');\n  }\n\n  // swipe listeners\n  element.addEventListener('touchstart', handleTouchStart, false);\n  element.addEventListener('touchend', handleTouchEnd, false);\n  element.addEventListener('touchcancel', handleTouchCancel, false);\n  element.addEventListener('touchmove', handleTouchMove, false);\n\n  // why not key listeners as well?\n  element.addEventListener('keydown', handleKeyDown, false);\n};\n\nexport default setupInputListeners;\n","const HIGH_SCORE_KEY = 'high_scores';\n\nconst saveHighScore = (score: number): void => {\n  const serializedHighScore = localStorage.getItem(HIGH_SCORE_KEY);\n\n  if (serializedHighScore === null) {\n    localStorage.setItem(HIGH_SCORE_KEY, JSON.stringify([score]));\n    return;\n  }\n\n  let highScore: number[] = JSON.parse(serializedHighScore);\n  highScore.push(score);\n  highScore.sort((a, b) => b - a);\n  if (highScore.length > 10) {\n    highScore.splice(10);\n  }\n  localStorage.setItem(HIGH_SCORE_KEY, JSON.stringify(highScore));\n};\n\nconst loadHighScore = (): number[] => {\n  const serializedHighScore = localStorage.getItem(HIGH_SCORE_KEY);\n\n  if (serializedHighScore === null) {\n    return [];\n  }\n\n  const highScore: number[] = JSON.parse(serializedHighScore);\n\n  return highScore;\n};\n\nconst highScore: HighScore = {\n  save: saveHighScore,\n  load: loadHighScore\n};\n\nexport default highScore;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","import readline = require('readline');\nimport { EventType } from '../eventDispatcher/enums';\nimport { SetupInputListenersParam } from './types';\n\nconst setupInputListeners = (param: SetupInputListenersParam): void => {\n  const { handleInput } = param;\n  readline.emitKeypressEvents(process.stdin);\n\n  if (\n    process === undefined ||\n    process.stdin === undefined ||\n    process.stdin.setRawMode === undefined\n  ) {\n    throw new Error('Unexpected undefined object');\n  }\n  process.stdin.setRawMode(true);\n\n  process.stdin.on('keypress', (_, key): void => {\n    if (key.ctrl && key.name === 'c') {\n      process.exit();\n    } else {\n      switch (key.name) {\n        case 'left':\n          handleInput(EventType.InputLeft);\n          break;\n        case 'right':\n          handleInput(EventType.InputRight);\n          break;\n        case 'up':\n          handleInput(EventType.InputUp);\n          break;\n        case 'down':\n          handleInput(EventType.InputDown);\n          break;\n        case 'q':\n          handleInput(EventType.RotateReverse);\n          break;\n        case 'e':\n          handleInput(EventType.Rotate);\n          break;\n        case 'r':\n          handleInput(EventType.Restart);\n          break;\n        case 'w':\n          handleInput(EventType.QuickDrop);\n          break;\n        case 'return':\n          handleInput(EventType.Confirmation);\n          break;\n        case 'escape':\n          handleInput(EventType.Pause);\n      }\n    }\n  });\n};\n\nexport default setupInputListeners;\n","let savedHighScore: number[] = [];\n\nconst loadHighScore = (): number[] => {\n  return savedHighScore;\n};\n\nconst saveHighScore = (score: number): void => {\n  const highScore = savedHighScore;\n  highScore.push(score);\n  highScore.sort((a, b) => b - a);\n  if (highScore.length > 10) {\n    highScore.splice(10);\n  }\n  savedHighScore = highScore;\n};\n\nconst highScore: HighScore = {\n  save: saveHighScore,\n  load: loadHighScore\n};\n\nexport default highScore;\n","import DependencyContainer from './dependencyContainer';\nimport { WEB_ENV, TERMINAL_ENV, createGameCharSelector } from './config';\nimport { Dependencies } from './dependencyContainer/types';\nimport initializeGame from './game';\n\nexport const main = async (GAME_ENV: string): Promise<void> => {\n  // register dependencies\n  let dependencies: Dependencies;\n  switch (GAME_ENV) {\n    case WEB_ENV:\n      dependencies = {\n        render: (await import('./render/web')).default(),\n        setupInputListeners: (await import('./input/web')).default,\n        gameCharSelector: createGameCharSelector(WEB_ENV),\n        highScore: (await import('./highScore/web')).default\n      };\n      break;\n    case TERMINAL_ENV:\n      dependencies = {\n        render: (await import('./render/terminal')).default,\n        setupInputListeners: (await import('./input/terminal')).default,\n        gameCharSelector: createGameCharSelector(TERMINAL_ENV),\n        highScore: (await import('./highScore/terminal')).default\n      };\n      break;\n    default:\n      throw new Error(`Unknown game environment - ${GAME_ENV}`);\n  }\n  DependencyContainer.initialize(dependencies);\n\n  initializeGame();\n};\n","import { main } from './index';\nimport { WEB_ENV } from './config';\n\nmain(WEB_ENV);\n"]}